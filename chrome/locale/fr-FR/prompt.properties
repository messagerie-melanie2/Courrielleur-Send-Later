# -*- coding: utf-8 -*-
sendaround=Programmer pour
entervalid=Saisir une date et un horaire valides
sendwithfunction=Envoyer selon la fonction “%1$S”
sendspecifyfunction=Sélectionnez une fonction dans le menu ci-dessous
January=Janvier
February=Février
March=Mars
April=Avril
May=Mai
June=Juin
July=Juillet
August=Août
September=Septembre
October=Octobre
November=Novembre
December=Décembre
OptionShortcutAlertTitle=Valeur de raccourci non valide
OptionShortcutAlertText=Le raccourci %1$S a une valeur non valide : « %2$S »
SendingUnsentError=Send Later : Erreur lors de l'envoi des messages différés. Votre dossier « Messages en attente » est peut-être corrompu et vos messages planifiés peuvent ne pas avoir été expédiés. Lire https://blog.kamens.us/send-later/#outbox.
CopyUnsentError=Send Later : Erreur lors de la copie du message vers « Messages en attente » pour expédition (code %x). Send Later a été désactivé ! Lire https://blog.kamens.us/send-later/#outbox-copy-failure.
CopyRecurError=Send Later : Erreur lors de la copie du message récurrent vers le dossier « Brouillons » (code %x). Send Later a été désactivé ! Lire https://blog.kamens.us/send-later/#drafts-copy-failure.
CorruptFolderError=Send Later : Le dossier %S est peut être endommagé. Veuillez afficher ses propriétés et cliquez sur « Réparer le dossier ». Lire https://blog.kamens.us/send-later/#corrupt-drafts-error.
MessageResendError=Send Later : Tenter de renvoyer un message déjà envoyer ?! Vos dossiers « Messages en attente » ou « Brouillons » %S sont peut-être corrompus. Veuillez procéder à leur réparation comme décrit sur https://blog.kamens.us/send-later/#corrupt-outbox.
minutely=à la minute
daily=quotidienne
weekly=hebdomadaire
monthly=mensuelle
yearly=annuelle
plural_minutely=aux minutes
plural_daily=jours
plural_weekly=semaines
plural_monthly=mois
plural_yearly=ans
every_minutely=toutes les %S minutes
every_daily=tous les %S jours
every_weekly=toutes les %S semaines
every_monthly=tous les %S mois
every_yearly=tous les %S ans
everyempty=semaine du mois
everymonthly=%1$S %2$S du mois
everymonthly_short=%1$S %2$S
betw_times=entre %S:%S et %S:%S
only_on_days=seulement les %S
day0=Dimanche
day1=Lundi
day2=Mardi
day3=Mercredi
day4=Jeudi
day5=Vendredi
day6=Samedi
ord1=1er
ord2=2e
ord3=3e
ord4=4e
ord5=5e
draftSaveWarning=ATTENTION : Afin d'éviter qu'Send Later expédie le message pendant sa modification, la planification a été supprimée. Pensez à le planifier à nouveau une fois terminé.
AreYouSure=Confirmation
OutboxConfirmMessage=« Placer en attente » mettra directement le message dans la boîte d'envoi. Le message NE SERA PAS programmé pour un envoi à un moment précis. À cette fin, cliquez sur « Programmer pour… » dans le cadre vert après avoir choisi une date d'envoi valide. Êtes-vous sûr de vouloir placer le message dans la boîte d'envoi maintenant ?
SendNowConfirmMessage=Cliquer sur “Envoyer maintenant” envoie le message immédiatement. Cela ne planifie PAS l'envoi du message à un moment ultérieur. Pour cela, il faut sélectionner
ConfirmAgain=Afficher cet avertissement la prochaine fois
ScheduledMessagesWarningTitle=Avertissement relatif aux envois programmés
ScheduledMessagesWarningQuitRequested=Il y a des envois porgrammés. Send Later ne peut envoyer de message que lorsque %S est ouvert. Etes-vous sûr de vouloir quitter?
ScheduledMessagesWarningQuit=Send Later ne peut envoyer de message que lorsque %S est ouvert. Pensez à le lancer pour que vos envois programmés soient expédiés!
EnigmailIncompatTitle=Problèmes de comptabilité entre Send Later et Enigmail
EnigmailIncompatText=La version installée d'Enigmail est incompatible avec Send Later. Par conséquent, la programmation des envois de messages par Send Later a été désactivée. Merci de contacter l'administrateur de Send Later (jik@kamens.us) pour toute demande d'assistance.
TimeMismatchConfirmTitle=Date d'envoi/restriction temporelle incompatibles.
TimeMismatchConfirmBody=La date d'expédition, %1$S, n'est pas compatible avec les restrictions temporelles spécifiées. Cliquez sur “Annuler” pour éditer la date d'expédition, ou “OK” pour ajuster automatiquement à %2$S.
endTimeWarningTitle=Restriction temporelle incorrecte.
endTimeWarningBody=Quand vous spécifiez une restriction temporelle, la date limite ne doit pas être antérieure à la date de départ. Merci de corriger la restriction temporelle ou de la désactiver.
missingDaysWarningTitle=Le choix des jour(s) de restriction est invalide.
missingDaysWarningBody=Vous avez activé un jour de restriction, sans choisir aucun jour. Merci de désactiver les restrictions  or préciser au moins un jour de distribution.
InvalidArgsTitle=Arguments de fonction invalides
InvalidArgsBody=Les paramètres de la fonction ne sont pas valides. Spécifiez une liste JavaScript, sans les parenthèses carrées ([ et ]).
BlockedLateMessage=Le message avec le sujet “%1$S” qui est dans le dossier brouillons %2$S était programmé pour être distribué il y a plus de %3$S minutes. Sa distribution a donc été bloquée. Vous devriez éditer le brouillon et l'envoyer ou le reprogrammer. Vous pouvez aussi désactiver l'option “Ne pas distribuer les messages en retard de plus de # minutes” afin d'empêcher l'envoi de messages en retard.
EditorReadMeCode=// Bienvenue sur l’éditeur de fonction Send Later !\n// \n// L’éditeur permet de créer des fonctions JavaScript d’application\n// complexe message logique de planification qui peut être associée à\n// des boutons de raccourci ou sélectionné dans la boîte de dialogue\n// Send Later.\n// \n// Comme vous pouvez le voir ci-dessus, lorsqu’une fonction de\n// planification est appelée, elle sera donnée trois arguments :\n// \n// * « specname » est nécessaire si vous souhaitez que cette fonction\n//   se reproduire (voir ci-dessous)\n// \n// * « prev » est la précédente à la demande envoyer à temps, si il\n//   s’agit d’un abonnement appel\n// \n// * « args » est les arguments supplémentaires retournées par l’appel\n//   précédent si ce est une invocation récurrente\n// \n// votre code a besoin définir les variables « next » ,\n// « nextspec », et « nextargs » comme suit :\n//\n// * « next » est le nombre de minutes dans le futur ou un objet\n//   Date qui indique quand le message doit être envoyé.\n// \n// * « nextspec » est une spécification de récurrence si cela est\n//   destiné à être un récurrents message (Voir\n//   https://blog.kamens.us/send-later/#dynamic-recurrence). Si vous\n//   ne définissez pas cela, alors que le message ne sera envoyée une\n//   fois. Remarque : Si vous souhaitez que votre fonction à appeler à\n//   nouveau pour la récurrence, do :\n// \n//   nextspec = "function " + specname;\n// \n// * « nextargs » est un tableau d’arguments à être passés dans\n//   l’autre appel de la fonction comme « args ».\n// \n// Pendant que vous travaillez sur votre fonction, vous pouvez le\n// tester en remplissant les valeurs pour « prev » et « args » dans\n// les zones de texte ci-dessous et puis en cliquant sur « Exécuter »\n// à exécuter la fonction et voir les résultats.\n// \n// Il y a deux exemples préconfigurée de fonctions, « BusinessHours »\n// et « DaysInARow », que vous pouvez regarder et jouer avec pour en\n// savoir plus.  Cette fonction « ReadMeFirst » pose simplement le\n// message à envoyer maintenant, autour de via la ligne suivante.\n\nnext = new Date();
EditorReadMeHelp=Le texte que vous écrirez ici sera affiché comme info-bulle quand vous survolerez la fonction dans le menu. Vous pouvez utiliser cet endroit pour indiquer ce que fait la fonction et quels paramètres elle accepte.
_BusinessHoursCode=// Valeurs par défaut\nvar workDays = [1, 2, 3, 4, 5]; // Jours travaillés : lundi à vendredi; Dimanche == 0, Samedi == 6\nvar workStart = [8, 30]; // Début de la journée de travail indiqué sur la forme [H, M]\nvar workEnd = [17, 30]; // Fin de la journée de travail indiquée sur la forme [H, M]\nif (args && args[0])\n    workDays = args[0];\nif (args && args[1])\n    workStart = args[1];\nif (args && args[2])\n    workEnd = args[2];\nif (prev)\n    // Inutile en usage normal, mais utilisé pour l'instant présent pour test.\n    next = new Date(prev);\nelse\n    next = new Date();\n// Si la fin de journée de travail est passée ou si aujourd'hui n'est pas un jour travaillé, \n//reporte à l'heure de début de travail du prochain jour travaillé.\nwhile ((next.getHours() > workEnd[0]) ||\n       (next.getHours() == workEnd[0] && next.getMinutes() > workEnd[1]) ||\n       (workDays.indexOf(next.getDay()) == -1)) {\n    next.setDate(next.getDate() + 1);\n    next.setHours(workStart[0]);\n    next.setMinutes(workStart[1]);\n}\n// Si la journée de travail n'a pas encore commencé, reporte à l'heure de début de la journée de travail.\nif ((next.getHours() < workStart[0]) ||\n    (next.getHours() == workStart[0] && next.getMinutes() < workStart[1])) {\n    next.setHours(workStart[0]);\n    next.setMinutes(workStart[1]);\n}
BusinessHoursHelp=Envoie le message immédiatement si c'est durant les heures de travail, ou au début de la prochaine journée travaillée. Vous pouvez changer la définition des jours de travail (valeurs par défaut : Lundi - Vendredi) en indiquant un tableau de nombres comme premier paramètre (work-day), avec 0 pour Dimanche et 6 pour Samedi. Vous pouvez changer les horaires de début et de fin d'une journée de travail (valeurs par défaut : 8h30 - 17h30) en modifiant pour chacun les tableaux [H, M] du deuxième et du troisième paramètre (workStart et workEnd). Indiquez “null” pour les paramètres précédemment définis que vous ne voulez pas modifier. Par exemple, “null, [9, 0], [17, 0]” change les horaires de travail sans changer les jours travaillés.
DaysInARowCode=// Envoie le premier message maintenant, puis une fois par jour.\nif (! prev)\n next = new Date();\nelse {\n var now = new Date();\n next = new Date(prev); // Copie le paramètre "date" pour qu'il ne soit pas modifié.\n do {\n next.setDate(next.getDate() + 1);\n } while (next < now);\n // ^^^ N'essayez pas d'envoyer un message dans le passé, si Thunderbird n'était pas ouvert \n //à l'heure qui était programmée pour l'envoi.\n}\nif (! args) // Envoie le message trois fois par défaut.\n args = [3];\nnextargs = [args[0] - 1];\n// Répétition si le nombre d'envoi n'a pas été suffisant.\nif (nextargs[0] > 0)\n nextspec = "function " + specname;
DaysInARowHelp=Envoyer le message maintenant, et ensuite une fois par jour à la même heure, jusqu'à ce qu'il ait été envoyé trois fois (ce nombre total d'envois est un paramètre que vous pouvez modifier)
DiscardConfirmTitle=Ignorer les modifications ?
DiscardConfirmBody=Il y a des modifications qui n'ont pas été enregistrées. Voulez-vous les ignorer ?
UntestedSaveTitle=Enregistrer la fonction sans la tester ?
UntestedSaveBody=La fonction n'a pas été testée (avec le bouton “exécuter”) depuis sa dernière modification. Êtes-vous sûr(e) de vouloir l'enregistrer ou l'exporter ?
BadSaveTitle=Nom ou code de fonction invalide
BadSaveBody=Vérifiez que le nom et le codage de la fonction sont valides avant d'enregistrer ou exporter.
ReplacingFunctionTitle=Remplacer la fonction existante ?
ReplacingFunctionBody=Une fonction avec ce nom existe déjà. Êtes-vous sûr(e) de vouloir la remplacer par celle-ci ?
NoNextValueError=La fonction n'a pas défini de valeur “next”
BadNextValueError=la valeur “next” “%1$S” n'est ni un nombre ni une date
BadNextArgsError=La valeur de “nextargs” “%1$S” n'est pas un tableau
FunctionDeleteConfirmBody=Êtes-vous sûr(e) de vouloir supprimer cette fonction ? Si elle est associée à des raccourcis, ils ne fonctionneront plus, et si des messages récurrents l'utilise, ils ne seront pas re-planifiés après le prochain envoi.
ImportTitle=Choisir le fichier à importer
SLJFilterLabel=Fichiers JSON pour Send Later
ImportError=Erreur d'importation
ExportTitle=Choisir un emplacement et un nom pour le fichier exporté.
RenameFunctionTitle=Renommer cette fonction ?
RenameFunctionBody=Vous avez modifié le nom d'une fonction existante,“%1$S”. Voulez-vous renommer cette fonction ou enregistrer une fonction différente avec ce nouveau nom ?
RenameFunctionRenameButton=Renommer
RenameFunctionNewButton=Créer
FunctionErrorTitle=Erreur lors de l'exécution d'une fonction dynamique
FunctionErrorBody=Erreur lors de l'exécution d'une fonction dynamique de programmation horaire: “%1$S”
cancel_on_reply=annuler en cas de réponse
